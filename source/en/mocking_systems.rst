.. _mocking_systems:

Mocking systems
#########################

TODO get mock parts from everywhere + add stuff from issues



.. _les-bouchons-mock:

The mocks
*******************

atoum has a powerful mock system and easy-to-implement allowing you to generate mocks from (existing, nonexistent, abstract or not) classes or interfaces. With these mocks, you can simulate behaviors by redefining the public methods of your classes.


Generate a mock
==================

There are several ways to create a mock from an interface or a class.

The simplest is to create an object with the absolute name is prefixed by ``mock``:

.. code-block:: php

   <?php
   // creation of a mock of the interface \Countable
   $countableMock = new \mock\Countable;

   // creation of a mock from the abstract class
   // \Vendor\Project\AbstractClass
   $vendorAppMock = new \mock\Vendor\Project\AbstractClass;

   // creation of mock of the \StdClass class
   $stdObject     = new \mock\StdClass;

   // creation of a mock from a non-existing class
   $anonymousMock = new \mock\My\Unknown\Class;


The mock generator
========================

atoum relies on a specialized component to generate the mock: the ``mockGenerator``. You have access to the latter in your tests in order to modify the procedure for generation of the mocks.

By default, the mock will be generated in the "mock" namespace and behave exactly in the same way as instances of the original class (mock inherits directly from the original class).


Change the name of the class
-----------------------------

If you wish to change the name of the class or its namespace, you must use the ``mockGenerator``.

Its method ``generate`` takes 3 parameters:

* the name of the interface or class to mock ;
* the new namespace, optional ;
* the new name of class, optional.

.. code-block:: php

   <?php
   // creation of a mock of the interface \Countable to \MyMock\Countable
   // we only change the namespace
   $this->mockGenerator->generate('\Countable', '\MyMock');

   // creation of a mock from the abstract class
   // \Vendor\Project\AbstractClass to \MyMock\AClass
   // change the namespace and class name
   $this->mockGenerator->generate('\Vendor\Project\AbstractClass', '\MyMock', 'AClass');

   // creation of a mock of \StdClass to \mock\OneClass
   // We only changes the name of the class
   $this->mockGenerator->generate('\StdClass', null, 'OneClass');

   // we can now instantiate these mocks
   $vendorAppMock = new \myMock\AClass;
   $countableMock = new \myMock\Countable;
   $stdObject     = new \mock\OneClass;

.. note::
If you use only the first argument and do not change the namespace or the name of the class, then the first solution is equivalent, easiest to read and recommended.

.. note::
You can access to the code from the class generated by the mock generator by calling ``$this->mockGenerator->getMockedClassCode()``, in order to debug, for example. This method takes the same arguments as the method ``generate``.

.. code-block:: php

   <?php
   $countableMock = new \mock\Countable;

   // is equivalent to:

   $this->mockGenerator->generate('\Countable');   // useless
   $countableMock = new \mock\Countable;


Shunt calls to parent methods
----------------------------------------

A mock inherits from the class from which it was generated, its methods therefore behave exactly the same way.

In some cases, it may be useful to shunt calls to parent methods so that their code is not run. The ``mockGenerator`` offers several methods to achieve this :

.. code-block:: php

   <?php
   // The mock will not call the parent class
   $this->mockGenerator->shuntParentClassCalls();

   $mock = new \mock\OneClass;

   // the mock will again call the parent class
   $this->mockGenerator->unshuntParentClassCalls();

Here, all mock methods will behave as if they had no implementation however they will keep the signature of the original methods. You can also specify the methods you want to shunt :

.. code-block:: php

   <?php
   // the mock will not call the parent class for the method firstMethodâ€¦...
   $this->mockGenerator->shunt('firstMethod');
   // ... nor for the method secondMethod
   $this->mockGenerator->shunt('secondMethod');

   $countableMock = new \mock\OneClass;


Make an orphan method
----------------------------

It may be interesting to make an orphan method, that is, give him a signature and implementation empty. This can be particularly useful for generating mocks without having to instantiate all their dependencies.

.. code-block:: php

   <?php
   class FirstClass {
       protected $dep;

       public function __construct(SecondClass $dep) {
           $this->dep = $dep;
       }
   }

   class SecondClass {
       protected $deps;

       public function __construct(ThirdClass $a, FourthClass $b) {
           $this->deps = array($a, $b);
       }
   }

   $this->mockGenerator->orphanize('__construct');
   $this->mockGenerator->shuntParentClassCalls();

   // We can instantiate the mock without injecting dependencies
   $mock = new \mock\SecondClass();

   $object = new FirstClass($mock);


Modify the behavior of a mock
=====================================

Once the mock created and instantiated, it is often useful to be able to change the behaviour of its methods.

To do this, you must use its controller using one of the following methods:

.. code-block:: php

   <?php
   $mockDbClient = new \mock\Database\Client();

   $mockDbClient->getMockController()->connect = function() {};
   // Equivalent to
   $this->calling($mockDbClient)->connect = function() {};

The ``mockController`` allows you to redefine **only public and abstract methods protected** and puts at your disposal several methods :

.. code-block:: php

   <?php
   $mockDbClient = new \mock\Database\Client();

   // Redefine the method connect: it will always return true
   $this->calling($mockDbClient)->connect = true;

   // Redefine the method select: it will execute the given anonymous function
   $this->calling($mockDbClient)->select = function() {
       return array();
   };

   // redefine the method query with arguments
   $result = array();
   $this->calling($mockDbClient)->query = function(Query $query) use($result) {
       switch($query->type) {
           case Query::SELECT:
               return $result

           default;
               return null;
       }
   };

   // the method connect will throw an exception
   $this->calling($mockDbClient)->connect->throw = new \Database\Client\Exception();

.. note::
The syntax uses anonymous functions (also called closures) introduced in PHP 5.3. Refer to `PHP manual <http://php.net/functions.anonymous>`__ for more information on the subject.

As you can see, it is possible to use several methods to get the desired behaviour:

* Use a static value that will be returned by the method
* Use a short implementation thanks to anonymous functions of PHP
* Use the ``throw`` keyword to throw an exception

You can also specify multiple values based on the order of call:

.. code-block:: php

   <?php
   // default
   $this->calling($mockDbClient)->count = rand(0, 10);
   // equivalent to
   $this->calling($mockDbClient)->count[0] = rand(0, 10);

   // 1st call
   $this->calling($mockDbClient)->count[1] = 13;

   // 3rd call
   $this->calling($mockDbClient)->count[3] = 42;

* The first call will return 13.
* The second will be the default behavior, it means a random number.
* The third call will return 42.
* All subsequent calls will have the default behaviour, i.e. random numbers.

If you want several methods of the mock have the same behavior, you can use the `methods`_ or `methodsMatching`_.


methods
-------

``methods`` allows you, thanks to the anonymous function passed as an argument, to define to what methods the behaviour must be modified :

.. code-block:: php

   <?php
   // if the method has such and such name,
   // we redefines its behavior
   $this
       ->calling($mock)
           ->methods(
               function($method) {
                   return in_array(
                       $method,
                       array(
                           'getOneThing',
                           'getAnOtherThing'
                       )
                   );
               }
           )
               ->return = uniqid()
   ;

   // we redefines the behavior of all methods
   $this
       ->calling($mock)
           ->methods()
               ->return = null
   ;

   // if the method begins by "get",
   // we redefines its behavior
   $this
       ->calling($mock)
           ->methods(
               function($method) {
                   return substr($method, 0, 3) == 'get';
               }
           )
               ->return = uniqid()
   ;


In the case of the last example, you should instead use `methodsMatching`_.

.. note::
The syntax uses anonymous functions (also called closures) introduced in PHP 5.3. Refer to `PHP manual <http://php.net/functions.anonymous>`__ for more information on the subject.


methodsMatching
-----------------

``methodsMatching`` allows you to set the methods where the behaviour must be modified using the regular expression passed as an argument :

.. code-block:: php

   <?php
   // if the method begins by "is",
   // we redefines its behavior
   $this
       ->calling($mock)
           ->methodsMatching('/^is/')
               ->return = true
   ;

   // if the method starts by "get" (case insensitive),
   // we redefines its behavior
   $this
       ->calling($mock)
           ->methodsMatching('/^get/i')
               ->throw = new \exception
   ;

.. note::
``methodsMatching`` use `preg_match <http://php.net/preg_match>`_ and regular expressions. Refer to the `PHP manual <http://php.net/pcre>`__ for more information on the subject.


Particular case of the constructor
===================================

To mock the constructor of a class, you need:

* create an instance of the \atoum\mock\controller class before you call the constructor of the mock ;
* set via this control the behaviour of the constructor of the mock using an anonymous function ;
* inject the controller during the instantiation of the mock in the last argument.

.. code-block:: php

   <?php
   $controller = new \atoum\mock\controller();
   $controller->__construct = function() {};

   $mockDbClient = new \mock\Database\Client(DB_HOST, DB_USER, DB_PASS, $controller);


Test mock
=================

atoum lets you verify that a mock was used properly.

.. code-block:: php

   <?php
   $mockDbClient = new \mock\Database\Client();
   $mockDbClient->getMockController()->connect = function() {};
   $mockDbClient->getMockController()->query   = array();

   $bankAccount = new \Vendor\Project\Bank\Account();
   $this
       // use of the mock via another object
       ->array($bankAccount->getOperations($mockDbClient))
           ->isEmpty()

       // test of the mock
       ->mock($mockDbClient)
           ->call('query')
               ->once() // check that the query method
                               // has been called only once
   ;

.. note::
Refer to the documentation on the :ref:`mock-asserter` for more information on testing mocks.


The mocking (mock) of native PHP functions
**************************************************
atoum allow to easyly simulate the behavious of native PHP functions.

.. code-block:: php

   <?php

   $this
      ->assert('the file exist')
         ->given($this->newTestedInstance())
         ->if($this->function->file_exists = true)
         ->then
         ->object($this->testedInstance->loadConfigFile())
            ->isTestedInstance()
            ->function('file_exists')->wasCalled()->once()

      ->assert('le fichier does not exist')
         ->given($this->newTestedInstance())
         ->if($this->function->file_exists = false )
         ->then
         ->exception(function() { $this->testedInstance->loadConfigFile(); })
   ;

.. important::
The \\ is not allowed before any functions to simulate because atoum take the resolution mechanism of PHP's namespace.

.. important::
For the same reason, if a native function was already called before, his mocking will be without any effect.

.. code-block:: php

   <?php

   $this
      ->given($this->newTestedInstance())
      ->exception(function() { $this->testedInstance->loadConfigFile(); }) // the function file_exists and is called before is mocking

      ->if($this->function->file_exists = true ) // the mocking can take the place of the native function file_exists
      ->object($this->testedInstance->loadConfigFile())
         ->isTestedInstance()
   ;
